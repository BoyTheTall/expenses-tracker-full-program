# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'TransactionsUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets, uic
from PyQt6.QtWidgets import QMainWindow, QApplication, QTableWidgetItem, QMessageBox
from PyQt6.QtGui import QIcon

import backend.Transaction as Transaction
import ui_files.messages as messages

class TransactionUI(QtWidgets.QMainWindow):
    rows_to_be_updated = []
    t_services = Transaction.transaction_services()
    transactions = []

    def __init__(self):
        super(TransactionUI, self).__init__()
        uic.loadUi('ui_files/TransactionsUI.ui', self)
        self.setWindowIcon(QIcon("icon.png"))
        self.show()

        self.prepare_table()
        self.transactions = self.t_services.getExpenses()
        self.populate_table(self.transactions)
        self.cmbTransactionType.addItems(["expense", "income"])

        self.btnAddTransaction_2.clicked.connect(self.btnAdd_function)
        self.btnDelete.clicked.connect(self.btnDelete_Function)
        self.btnUpdate.clicked.connect(self.btnUpdate_Function)
        self.btnSearch_2.clicked.connect(self.btnSearch_funtion)

        self.chkSpecificDate.clicked.connect(self.date_search_type_specific_date)
        self.chkMonthYear.clicked.connect(self.date_search_month_year_type)
        self.cmbMode.activated.connect(self.mode_selection)
        self.tblTransactions_2.itemChanged.connect(self.on_item_edited)

    def prepare_table(self):
        self.tblTransactions_2.setColumnCount(5)
        self.tblTransactions_2.setHorizontalHeaderLabels([
            "Transaction_ID", "Transaction Type", "Date", "Category", "Amount"
        ])
        for i in range(5):
            self.tblTransactions_2.setColumnWidth(i, 164)

    def populate_table(self, transactions_arr):
        self.tblTransactions_2.setRowCount(0)
        for i, t in enumerate(transactions_arr):
            self.tblTransactions_2.insertRow(i)
            self.tblTransactions_2.setItem(i, 0, QTableWidgetItem(str(t.getTransactionId())))
            self.tblTransactions_2.setItem(i, 1, QTableWidgetItem(t.getTransactionType()))
            self.tblTransactions_2.setItem(i, 2, QTableWidgetItem(t.getDate()))
            self.tblTransactions_2.setItem(i, 3, QTableWidgetItem(t.getCategory()))
            self.tblTransactions_2.setItem(i, 4, QTableWidgetItem(str(t.getAmount())))
   
    #this saves the new transactions into the backend
    def add_transactions(self):
        transactions_to_be_added = self.getTransactions_from_table()
        
        if(len(transactions_to_be_added) == 0):
            message = "There are no transactions entered. Please enter at least one transaction"
            title = "Error :("
            messages.display_message(message, title, messages.ERROR_MSG)
        
        else:
            message = """Are you sure you want to add these?, Please Make sure all details are correct
                 searching by criteria  just to fix one is gonna be a pain unless you know the transaction ID"""
            title = "Mmmmmmm"
            add_transactions_to_database = messages.display_option_message(message, title)
            if (add_transactions_to_database == True):
                for i in range(0, len(transactions_to_be_added)):
                    self.t_services.add_transaction(transactions_to_be_added[i])
                message = "Transactions added successfully"
                title = "yay :)"
                messages.display_message(message, title, messages.INFO_MSG)
            else:
                message = "Do you wish to restore the previous list of transactions?"
                title = "Do you though?"
                restore_flag = messages.display_option_message(message, title)
                if restore_flag ==  True:
                    self.populate_table(self.transactions)
                else:
                    self.clear_table()

    #gets all the transactions that are in the table ui element, will be used in in the add transactions mode mostly
    def getTransactions_from_table(self):
        
        number_of_transactions = self.tblTransactions_2.rowCount()
        transactions = []
        for i in range(0, number_of_transactions):
            transaction_id = str(self.tblTransactions_2.item(i, 0).text())
            transaction_type = str(self.tblTransactions_2.item(i, 1).text())
            t_date = str(self.tblTransactions_2.item(i, 2).text())
            category = str(self.tblTransactions_2.item(i, 3).text())
            amount = float(self.tblTransactions_2.item(i, 4).text())
            transaction_t = Transaction.transaction(transaction_id, amount, category, transaction_type, t_date)
            transactions.append(transaction_t)
            
        return transactions

    #fetches the list of transactions that meet the specified parameters
    def fetch_transactions(self):
        search_by_category = self.chkboxCategory.isChecked()
        search_by_transaction_type = self.chkboxTransactionType.isChecked()
        search_by_specific_date = self.chkSpecificDate.isChecked()
        search_by_month_and_year = self.chkMonthYear.isChecked()
        
        t_id = None
        date = None
        category = None
        t_type = None
        date_type = None
        
        if search_by_category == True:
            category = self.cmbCategory.currentText()
            
        if search_by_transaction_type == True:
            t_type = self.cmbTransactionType.currentText()
        
        if search_by_specific_date ==True:
            date = self.get_date_for_search()
            date_type = self.t_services.SPECIFIC_DATE
        
        if search_by_month_and_year == True:
            date = str(self.cmbMonth.currentIndex() + 1) + '/' + self.txtYear.text()
            date_type = self.t_services.MONTH_AND_YEAR
        
        self.transactions = self.t_services.getTransactions(t_id, date, category, t_type, date_type)
        if(len(self.transactions) >= 1):
            self.tblTransactions_2.setRowCount(0)
            self.populate_table(self.transactions)
        else:
            message = "No Transactions that meet the search criteria were found"
            title = "Operation Failed"
            messages.display_message(message, title, messages.ERROR_MSG)

    #removes all transactions in the table ui element
    def clear_table(self):
        self.tblTransactions_2.setRowCount(0)

    #this provides the functionality of the ui element repsonsible for choosing the mode that the screen is in and makes the changes
    #to the labels and button texts that show the user the mode and functionality each element has
    def mode_selection(self):
        if self.cmbMode.currentText() == "Add Transaction":
            self.clear_table()        
            self.btnSearch_2.setText("Insert New Blank Row")
            self.btnUpdate.setText("Clear Current Row")
            self.btnDelete.setText("Delete Row")
            
                     
        else:
            self.btnSearch_2.setText("Search")
            self.btnUpdate.setText("Update")
            self.btnDelete.setText("Delete")
            
            message = "Do you want to load the previous transactions?"
            title = "Load Previous Transactions"
            
            if len(self.transactions) >= 1:
                r = messages.display_option_message(message, title, messages.INFO_MSG)
                if r == True:
                    self.populate_table(self.transactions)

    #this is the function that will be linked to the search button and will choose the appropriate function depending on the mode
    def btnSearch_funtion(self):
        if self.cmbMode.currentText() == "Add Transaction":
            #in this case the button will be in insert empty row mode
            position = self.tblTransactions_2.rowCount()
            self.tblTransactions_2.insertRow(position)
            self.tblTransactions_2.setItem(position, 0, QtWidgets.QTableWidgetItem(str(Transaction.generate_ID())))
        else:
            #button will be in search mode
            self.fetch_transactions()

    #this is the function that will be linked to the add transaction button and will choose the appropriate function depending on the mode
    def btnAdd_function(self):
        if self.cmbMode.currentText() == "Add Transaction":
            self.add_transactions()
        
        else:
            message = "Functionality of this button is disabled in this mode"
            title = "oopsie *_*"
            messages.display_message(message, title, messages.INFO_MSG)

    #this is the function that will be linked to the delete button and will choose the appropriate function depending on the mode
    def btnDelete_Function(self):
        if self.cmbMode.currentText() == "Add Transaction":
            #removes the selected rows in this mode
            highlighted_rows = self.tblTransactions_2.selectedIndexes()
            for i in range(0, len(highlighted_rows)):
                self.tblTransactions_2.removeRow(highlighted_rows[i].row())
                
        else:
            self.delete_transactions_function()
            
    #this is the function that will be linked to the update button and will choose the appropriate function depending on the mode
    def btnUpdate_Function(self):
        if self.cmbMode.currentText() == "Add Transaction":
            self.clear_rows()
        
        else:
            confirm_actions = messages.display_option_message("are you sure you want to do this?", "mmmmm :|")
            if confirm_actions == True:
                transactions_to_be_updated = self.get_specified_transactions()
                if len(transactions_to_be_updated) == 0:
                    message = "Error, no changes were made to any transactions. Update cannot be done"
                    title = "Error"
                    messages.display_message(message, title, messages.ERROR_MSG)
                else:
                    for i in range(0, len(transactions_to_be_updated)):
                        self.t_services.update_transaction(transactions_to_be_updated[i])
            
                    message = "Transactions updated successfully :)"
                    title = "Done :)"
                    messages.display_message(message=message, title=title, message_type=messages.INFO_MSG)
            else:
                message = "Load previous Transactions? This will remove all the changes you have made."
                title = "are you sure"
                load_previous_transactions = messages.display_option_message(message, title)
                if load_previous_transactions == True:
                    self.populate_table(self.transactions)
                    message = "transactions loaded successfully"
                    title = "it is done"
                    messages.display_message(message, title, messages.INFO_MSG)
                else:
                    messages.display_message("Your changes were kept, these were not saved we just didnt revert to the previous loaded list", "Ok", messages.INFO_MSG) 
   
    #this gets the transactions selected by the user      
    def getHighlightedTransactions(self):
        selected_table_indexes = self.tblTransactions_2.selectedIndexes()
        highlighted_transactions = []
        for i in range(0, len(selected_table_indexes)):
            current_row = selected_table_indexes[i].row()
            
            transaction_id = self.tblTransactions_2.item(current_row, 0).text()
            transaction_type = self.tblTransactions_2.item(current_row, 1).text()
            t_date = self.tblTransactions_2.item(current_row, 2).text()
            category = self.tblTransactions_2.item(current_row, 3).text()
            amount = float(self.tblTransactions_2.item(current_row, 4).text())
            transaction_t = Transaction.transaction(transaction_id, amount, category, transaction_type, t_date)
            highlighted_transactions.append(transaction_t)
      
        return highlighted_transactions
 
    #this contains the logic for actually deleting transactions in the UI including all the confirmations and roll backs
    def delete_transactions_function(self):
        message = "are you sure you want to delete the selected transaction(s)?"
        title  = "mmmmmmm :|"
        
        action_confirmation = messages.display_option_message(message, title)
        if action_confirmation == True:
            transactions_to_be_deleted = self.getHighlightedTransactions()
            self.t_services.delete_multiple_transactions(transaction_list=transactions_to_be_deleted)
            messages.display_message(message="Delete operation successful", title="They're gone :/", message_type=messages.INFO_MSG)
        
        else:
            message = "Action cancelled"
            title = "Info"
            messages.display_message(message, title, messages.INFO_MSG)
    
    #this deselects the other check box when the search by specific date checkbox is clicked
    def date_search_type_specific_date(self):
        self.chkMonthYear.setChecked(False)
    
    #this deselects the other check box when the search by month and yearc heckbox is clicked
    def date_search_month_year_type(self):
        self.chkSpecificDate.setChecked(False)
    
    #this function clears the selected transactions (the highlighted ones), mostly used in add transaction mode
    def clear_rows(self):
        indexes = self.tblTransactions_2.selectedIndexes()
        for i in range(0, len(indexes)):
            self.tblTransactions_2.setItem(indexes[i].row(), 1,QtWidgets.QTableWidgetItem(None))
            self.tblTransactions_2.setItem(indexes[i].row(), 2, QtWidgets.QTableWidgetItem(None))
            self.tblTransactions_2.setItem(indexes[i].row(), 3, QtWidgets.QTableWidgetItem(None))
            self.tblTransactions_2.setItem(indexes[i].row(), 4, QtWidgets.QTableWidgetItem(None))
        messages.display_message(message="Cleared Succesfully", title="It's done boss", message_type=messages.INFO_MSG)
    
    # I have to make something that takes a list of the changed transactions and use that when calling the update function because updating everything will be inefficient  
    def on_item_edited(self, item):
        if self.cmbMode.currentText() == "Add Transaction":
            None
        else:
            row = item.row()
            self.rows_to_be_updated.append(row)

    
    #This one gets the transactions  that are specified by a set of rows instead of getting the highlighted transactions          
    def get_specified_transactions(self):
        rows_list = list(set(self.rows_to_be_updated))
        self.rows_to_be_updated = [] #clearing the global list of variables
        specified_transactions = []
        for i in range (0, len(rows_list)):
            current_row = rows_list[i]
            transaction_id = self.tblTransactions_2.item(current_row, 0).text()
            transaction_type = self.tblTransactions_2.item(current_row, 1).text()
            t_date = self.tblTransactions_2.item(current_row, 2).text()
            category = self.tblTransactions_2.item(current_row, 3).text()
            amount = float(self.tblTransactions_2.item(current_row, 4).text())
            transaction_t = Transaction.transaction(transaction_id, amount, category, transaction_type, t_date)
            specified_transactions.append(transaction_t)
        return specified_transactions
    
    #this is for getting the specific date combining all the texts from the multiple spin boxes
    def get_date_for_search(self):
        day = self.spnDay.cleanText()
        month = self.spnMonth.cleanText()
        year = self.spnYear.cleanText()
        date = day + "/" + month + "/" + year
        
        return date
        
             
if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    app.setStyle("Fusion")
    window = TransactionUI()
    app.exec()
